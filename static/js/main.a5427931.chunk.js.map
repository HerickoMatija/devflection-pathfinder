{"version":3,"sources":["pathfinding-algorithms/priorityQueue.js","pathfinding-algorithms/common.js","pathfinding-algorithms/astar.js","pathfinding-algorithms/dijkstra.js","visualizing/visualization.js","pathfinder/node/Node.jsx","menu-bar/MenuBar.jsx","pathfinder/PathFinder.jsx","pathfinding-algorithms/bfs.js","pathfinding-algorithms/dfs.js","App.js","serviceWorker.js","index.js"],"names":["PriorityQueue","getValueFunction","setValueFunction","this","_heap","_map","Map","length","node","push","set","mapNodeKey","siftUp","_swap","toRemove","pop","delete","siftDown","startIdx","currentIdx","parentIdx","getParent","_order","leftChildIdx","getLeftChild","idxToSwap","rightChildIdx","getRightChild","newDistance","get","distance","idx","idxOne","idxTwo","temp","nodeOne","nodeTwo","Math","floor","row","col","getUnvisitedNeighbors","grid","neighbors","neighbor","isVisited","isWall","astar","startNode","finishNode","visitedNodesInOrder","totalDistance","priorityQueue","createPriorityQueue","size","closestNode","Infinity","updateNeighbourDistances","unvisitedNeighbors","unvisitedNeighbor","manhattanDistance","updateOrder","previousNode","abs","newValue","dijkstra","weight","getNeighbourWeight","neighbour","animateSearch","shortestPathInOrder","animationTimers","entries","index","setTimeout","addCssClassToNode","animateShortestPath","cssClass","document","getElementById","className","Node","props","isStart","isFinish","onMouseDown","onMouseUp","onMouseEnter","onMouseLeave","id","getNodeClasses","Component","MenuBar","bfs","dfs","reset","buttonsEnabled","onClick","disabled","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","Pathfinder","state","getInitialGrid","window","innerWidth","innerHeight","setState","animationTimer","clearTimeout","Promise","resolve","then","selectedAlgorithm","queue","current","shift","nodesInShortestPathOrder","currentNode","unshift","rebuildShortestPathFromFinishNode","mouseIsPressed","movingNode","newGrid","getGridWithCellWallToggled","visualize","resetBoard","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseLeave","handleMouseUp","width","height","availableWidth","availableHeight","possibleRows","possibleCols","random","currentRow","createNode","slice","newNode","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.a5427931.chunk.js","sourcesContent":["export class PriorityQueue {\r\n  constructor(getValueFunction, setValueFunction) {\r\n    this._heap = [];\r\n    this._map = new Map();\r\n    this.getValueFunction = getValueFunction;\r\n    this.setValueFunction = setValueFunction;\r\n  }\r\n\r\n  size() {\r\n    return this._heap.length;\r\n  }\r\n\r\n  peek() {\r\n    return this._heap[0];\r\n  }\r\n\r\n  push(node) {\r\n    this._heap.push(node);\r\n    this._map.set(mapNodeKey(node), this._heap.length - 1);\r\n    this.siftUp(this._heap.length - 1);\r\n  }\r\n\r\n  pop() {\r\n    this._swap(0, this._heap.length - 1);\r\n    const toRemove = this._heap.pop();\r\n    this._map.delete(mapNodeKey(toRemove));\r\n    this.siftDown();\r\n    return toRemove;\r\n  }\r\n\r\n  siftUp(startIdx) {\r\n    let currentIdx = startIdx;\r\n    let parentIdx = getParent(currentIdx);\r\n\r\n    while (\r\n      currentIdx !== 0 &&\r\n      this._order(currentIdx) < this._order(parentIdx)\r\n    ) {\r\n      this._swap(currentIdx, parentIdx);\r\n      currentIdx = parentIdx;\r\n      parentIdx = getParent(currentIdx);\r\n    }\r\n  }\r\n\r\n  siftDown() {\r\n    let currentIdx = 0;\r\n    let leftChildIdx = getLeftChild(currentIdx);\r\n\r\n    while (leftChildIdx < this._heap.length) {\r\n      let idxToSwap = leftChildIdx;\r\n\r\n      let rightChildIdx = getRightChild(currentIdx);\r\n\r\n      if (\r\n        rightChildIdx < this._heap.length &&\r\n        this._order(rightChildIdx) < this._order(leftChildIdx)\r\n      ) {\r\n        idxToSwap = rightChildIdx;\r\n      }\r\n\r\n      if (this._order(currentIdx) < this._order(idxToSwap)) {\r\n        return;\r\n      } else {\r\n        this._swap(currentIdx, idxToSwap);\r\n        currentIdx = idxToSwap;\r\n        leftChildIdx = getLeftChild(currentIdx);\r\n      }\r\n    }\r\n  }\r\n\r\n  updateOrder(node, newDistance) {\r\n    let currentIdx = this._map.get(mapNodeKey(node));\r\n\r\n    if (this._heap[currentIdx].distance < newDistance) {\r\n        return\r\n    }\r\n\r\n    this.setValueFunction(this._heap[currentIdx], newDistance);\r\n    for (let idx = this._heap.length - 1; idx > 0; idx--) {\r\n      this.siftUp(currentIdx);\r\n    }\r\n  }\r\n\r\n  _order(idx) {\r\n    return this.getValueFunction(this._heap[idx]);\r\n  }\r\n\r\n  _swap(idxOne, idxTwo) {\r\n    const temp = this._heap[idxOne];\r\n    this._heap[idxOne] = this._heap[idxTwo];\r\n    this._heap[idxTwo] = temp;\r\n\r\n    const nodeOne = this._heap[idxOne];\r\n    const nodeTwo = this._heap[idxTwo];\r\n\r\n    this._map.set(mapNodeKey(nodeOne), idxOne);\r\n    this._map.set(mapNodeKey(nodeTwo), idxTwo);\r\n  }\r\n}\r\n\r\nconst getParent = (idx) => Math.floor((idx - 1) / 2);\r\nconst getLeftChild = (idx) => idx * 2 + 1;\r\nconst getRightChild = (idx) => idx * 2 + 2;\r\n\r\nconst mapNodeKey = (node) => node.row + \"-\" + node.col;\r\n","export function getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n\r\n  if (col > 0) {\r\n    const neighbor = grid[row][col - 1];\r\n    if (!neighbor.isVisited && !neighbor.isWall) {\r\n      neighbors.push(neighbor);\r\n    }\r\n  }\r\n  if (row > 0) {\r\n    const neighbor = grid[row - 1][col];\r\n    if (!neighbor.isVisited && !neighbor.isWall) {\r\n      neighbors.push(neighbor);\r\n    }\r\n  }\r\n  if (col < grid[0].length - 1) {\r\n    const neighbor = grid[row][col + 1];\r\n    if (!neighbor.isVisited && !neighbor.isWall) {\r\n      neighbors.push(neighbor);\r\n    }\r\n  }\r\n  if (row < grid.length - 1) {\r\n    const neighbor = grid[row + 1][col];\r\n    if (!neighbor.isVisited && !neighbor.isWall) {\r\n      neighbors.push(neighbor);\r\n    }\r\n  }\r\n\r\n  return neighbors;\r\n}\r\n\r\nexport function rebuildShortestPathFromFinishNode(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n\r\n  let currentNode = finishNode;\r\n\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import { PriorityQueue } from \"./priorityQueue\";\r\nimport { getUnvisitedNeighbors } from \"./common\";\r\n\r\nexport function astar(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n\r\n  startNode.totalDistance = 0;\r\n  const priorityQueue = createPriorityQueue(grid);\r\n\r\n  while (priorityQueue.size() !== 0) {\r\n    const closestNode = priorityQueue.pop();\r\n\r\n    if (closestNode.totalDistance === Infinity) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    closestNode.isVisited = true;\r\n\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    if (closestNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    updateNeighbourDistances(priorityQueue, closestNode, grid, finishNode);\r\n  }\r\n}\r\n\r\nfunction updateNeighbourDistances(priorityQueue, node, grid, finishNode) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n\r\n  for (const unvisitedNeighbor of unvisitedNeighbors) {\r\n    const totalDistance = manhattanDistance(unvisitedNeighbor, finishNode);\r\n\r\n    priorityQueue.updateOrder(unvisitedNeighbor, totalDistance);\r\n    unvisitedNeighbor.totalDistance = totalDistance;\r\n    unvisitedNeighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction manhattanDistance(node, finishNode) {\r\n  return (\r\n    Math.abs(node.row - finishNode.row) + Math.abs(node.col - finishNode.col)\r\n  );\r\n}\r\n\r\nfunction createPriorityQueue(grid) {\r\n  const priorityQueue = new PriorityQueue(getValueFunction, setValueFunction);\r\n\r\n  for (let row of grid) {\r\n    for (let node of row) {\r\n      priorityQueue.push(node);\r\n    }\r\n  }\r\n\r\n  return priorityQueue;\r\n}\r\n\r\nconst getValueFunction = (node) => node.totalDistance;\r\nconst setValueFunction = (node, newValue) => (node.totalDistance = newValue);\r\n","import { PriorityQueue } from \"./priorityQueue\";\r\nimport { getUnvisitedNeighbors } from \"./common\";\r\n\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n\r\n  startNode.distance = 0;\r\n  const priorityQueue = createPriorityQueue(grid);\r\n\r\n  while (priorityQueue.size() !== 0) {\r\n    const closestNode = priorityQueue.pop();\r\n\r\n    if (closestNode.distance === Infinity) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    closestNode.isVisited = true;\r\n\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    if (closestNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    updateNeighbourDistances(priorityQueue, closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction updateNeighbourDistances(priorityQueue, node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n\r\n  for (const unvisitedNeighbor of unvisitedNeighbors) {\r\n    let weight = getNeighbourWeight(node, unvisitedNeighbor)\r\n\r\n    priorityQueue.updateOrder(unvisitedNeighbor, node.distance + weight);\r\n    unvisitedNeighbor.distance = node.distance + weight;\r\n    unvisitedNeighbor.isVisited = true;\r\n    unvisitedNeighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction createPriorityQueue(grid) {\r\n  const priorityQueue = new PriorityQueue(getValueFunction, setValueFunction);\r\n\r\n  for (let row of grid) {\r\n    for (let node of row) {\r\n      priorityQueue.push(node);\r\n    }\r\n  }\r\n\r\n  return priorityQueue;\r\n}\r\n\r\nfunction getNeighbourWeight(node, neighbour) {\r\n    if (node.row === neighbour.row) {\r\n        return 5;\r\n    }    \r\n    if (node.row < neighbour.row) {\r\n        return 1;\r\n    }\r\n    if (node.row > neighbour.row) {\r\n        return 10;\r\n    }\r\n}\r\n\r\nconst getValueFunction = (node) => node.distance;\r\nconst setValueFunction = (node, newValue) => (node.distance = newValue);\r\n","export function animateSearch(visitedNodesInOrder, shortestPathInOrder) {\r\n  const animationTimers = [];\r\n\r\n  for (let [index, node] of visitedNodesInOrder.entries()) {\r\n    animationTimers.push(\r\n      setTimeout(() => {\r\n        addCssClassToNode(node, \"node-visited\");\r\n      }, 10 * index)\r\n    );\r\n  }\r\n\r\n  animationTimers.push(\r\n    setTimeout(() => {\r\n      animateShortestPath(shortestPathInOrder, animationTimers);\r\n    }, 10 * visitedNodesInOrder.length)\r\n  );\r\n\r\n  return animationTimers;\r\n}\r\n\r\nfunction animateShortestPath(shortestPathInOrder, animationTimers) {\r\n  if (shortestPathInOrder.length === 1) {\r\n    return;\r\n  }\r\n\r\n  for (let [index, node] of shortestPathInOrder.entries()) {\r\n    animationTimers.push(\r\n      setTimeout(() => {\r\n        addCssClassToNode(node, \"node-shortest-path\");\r\n      }, 25 * index)\r\n    );\r\n  }\r\n}\r\n\r\nfunction addCssClassToNode(node, cssClass) {\r\n  const nodeElement = document.getElementById(`node-${node.row}-${node.col}`);\r\n  nodeElement.className = `node ${cssClass}`;\r\n}\r\n","import React, { Component } from \"react\";\r\n\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      row,\r\n      col,\r\n      isStart,\r\n      isFinish,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseUp,\r\n      onMouseEnter,\r\n      onMouseLeave,\r\n    } = this.props;\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={getNodeClasses(isStart, isFinish, isWall)}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseLeave={() => onMouseLeave(row, col)}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n\r\nconst getNodeClasses = (isStart, isFinish, isWall) => {\r\n  if (isWall) {\r\n    return \"node node-wall\";\r\n  }\r\n  if (!isStart && !isFinish) {\r\n    return \"node\";\r\n  }\r\n  if (isStart) {\r\n    return \"node node-start\";\r\n  }\r\n  if (isFinish) {\r\n    return \"node node-finish\";\r\n  }\r\n};\r\n","import React, { Component } from \"react\";\r\n\r\nimport \"./MenuBar.css\";\r\n\r\nexport default class MenuBar extends Component {\r\n  render() {\r\n    const { astar, bfs, dfs, dijkstra, reset, buttonsEnabled } = this.props;\r\n\r\n    return (\r\n      <div className=\"menu-container\">\r\n        <div className=\"menu\">\r\n          <button\r\n            id=\"bfs-btn\"\r\n            className=\"menu-btn\"\r\n            onClick={() => astar()}\r\n            disabled={!buttonsEnabled}\r\n          >\r\n            Visualize A*\r\n          </button>\r\n          <button\r\n            id=\"bfs-btn\"\r\n            className=\"menu-btn\"\r\n            onClick={() => bfs()}\r\n            disabled={!buttonsEnabled}\r\n          >\r\n            Visualize BFS\r\n          </button>\r\n          <button\r\n            id=\"dfs-btn\"\r\n            className=\"menu-btn\"\r\n            onClick={() => dfs()}\r\n            disabled={!buttonsEnabled}\r\n          >\r\n            Visualize DFS\r\n          </button>\r\n          <button\r\n            id=\"dfs-btn\"\r\n            className=\"menu-btn\"\r\n            onClick={() => dijkstra()}\r\n            disabled={!buttonsEnabled}\r\n          >\r\n            Visualize Dijkstra's\r\n          </button>\r\n          <button id=\"reset-btn\" className=\"menu-btn\" onClick={() => reset()}>\r\n            Reset board\r\n          </button>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\n\r\nimport { astar } from \"../pathfinding-algorithms/astar\";\r\nimport { bfs } from \"../pathfinding-algorithms/bfs\";\r\nimport { dfs } from \"../pathfinding-algorithms/dfs\";\r\nimport { dijkstra } from \"../pathfinding-algorithms/dijkstra\";\r\nimport { rebuildShortestPathFromFinishNode } from \"../pathfinding-algorithms/common\";\r\nimport { animateSearch } from \"../visualizing/visualization\";\r\n\r\nimport Node from \"./node/Node\";\r\nimport MenuBar from \"../menu-bar/MenuBar\";\r\n\r\nimport \"./Pathfinder.css\";\r\n\r\nconst A_STAR = \"astar\";\r\nconst BFS = \"bfs\";\r\nconst DFS = \"dfs\";\r\nconst DIJKSTRA = \"dijkstra\";\r\n\r\nlet START_NODE_ROW = 0;\r\nlet START_NODE_COL = 0;\r\nlet FINISH_NODE_ROW = 1;\r\nlet FINISH_NODE_COL = 1;\r\n\r\nexport default class Pathfinder extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: [],\r\n      startNode: null,\r\n      finishNode: null,\r\n      buttonsEnabled: true,\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = getInitialGrid(window.innerWidth, window.innerHeight);\r\n\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n\r\n    this.setState({ grid, startNode, finishNode });\r\n  }\r\n\r\n  resetBoard() {\r\n    const { animationTimers } = this.state;\r\n\r\n    if (animationTimers) {\r\n      for (let animationTimer of animationTimers) {\r\n        clearTimeout(animationTimer);\r\n      }\r\n    }\r\n\r\n    const grid = getInitialGrid(window.innerWidth, window.innerHeight);\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n\r\n    Promise.resolve().then(() => {\r\n      this.setState({\r\n        grid: [],\r\n      });\r\n    });\r\n\r\n    Promise.resolve().then(() => {\r\n      this.setState({\r\n        grid,\r\n        startNode,\r\n        finishNode,\r\n        animationTimers: null,\r\n        buttonsEnabled: true,\r\n      });\r\n    });\r\n  }\r\n\r\n  visualize(selectedAlgorithm) {\r\n    const { grid, startNode, finishNode } = this.state;\r\n\r\n    let visitedNodesInOrder;\r\n    if (selectedAlgorithm === A_STAR) {\r\n      visitedNodesInOrder = astar(grid, startNode, finishNode);\r\n    } else if (selectedAlgorithm === BFS) {\r\n      visitedNodesInOrder = bfs(grid, startNode, finishNode);\r\n    } else if (selectedAlgorithm === DFS) {\r\n      visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n    } else if (selectedAlgorithm === DIJKSTRA) {\r\n      visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    }\r\n\r\n    const shortestPathInOrder = rebuildShortestPathFromFinishNode(finishNode);\r\n\r\n    const animationTimers = animateSearch(\r\n      visitedNodesInOrder,\r\n      shortestPathInOrder\r\n    );\r\n\r\n    this.setState({ buttonsEnabled: false, animationTimers });\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    const node = this.state.grid[row][col];\r\n\r\n    if (node.isStart) {\r\n      this.setState({ mouseIsPressed: true, movingNode: \"start\" });\r\n    } else if (node.isFinish) {\r\n      this.setState({ mouseIsPressed: true, movingNode: \"finish\" });\r\n    } else {\r\n      const newGrid = getGridWithCellWallToggled(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    }\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n\r\n    const node = this.state.grid[row][col];\r\n\r\n    if (this.state.movingNode === \"start\") {\r\n      node.isStart = true;\r\n      this.setState({ startNode: node });\r\n    } else if (this.state.movingNode === \"finish\") {\r\n      node.isFinish = true;\r\n      this.setState({ finishNode: node });\r\n    } else {\r\n      const newGrid = getGridWithCellWallToggled(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid });\r\n    }\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({ mouseIsPressed: false, movingNode: \"\" });\r\n  }\r\n\r\n  handleMouseLeave(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n\r\n    const node = this.state.grid[row][col];\r\n\r\n    if (this.state.movingNode === \"start\") {\r\n      node.isStart = false;\r\n      this.setState({ startNode: node });\r\n    } else if (this.state.movingNode === \"finish\") {\r\n      node.isFinish = false;\r\n      this.setState({ finishNode: node });\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const { grid, buttonsEnabled } = this.state;\r\n\r\n    return (\r\n      <>\r\n        <MenuBar\r\n          astar={() => this.visualize(A_STAR)}\r\n          bfs={() => this.visualize(BFS)}\r\n          dfs={() => this.visualize(DFS)}\r\n          dijkstra={() => this.visualize(DIJKSTRA)}\r\n          reset={() => this.resetBoard()}\r\n          buttonsEnabled={buttonsEnabled}\r\n        ></MenuBar>\r\n\r\n        <div className=\"pathfinder-main\">\r\n          <div className=\"grid\">\r\n            {grid.map((row, rowIdx) => {\r\n              return (\r\n                <div key={rowIdx}>\r\n                  {row.map((node, nodeIdx) => {\r\n                    const { row, col, isStart, isFinish, isWall } = node;\r\n                    return (\r\n                      <Node\r\n                        key={nodeIdx}\r\n                        col={col}\r\n                        row={row}\r\n                        isStart={isStart}\r\n                        isFinish={isFinish}\r\n                        isWall={isWall}\r\n                        onMouseDown={(row, col) =>\r\n                          this.handleMouseDown(row, col)\r\n                        }\r\n                        onMouseEnter={(row, col) =>\r\n                          this.handleMouseEnter(row, col)\r\n                        }\r\n                        onMouseLeave={(row, col) =>\r\n                          this.handleMouseLeave(row, col)\r\n                        }\r\n                        onMouseUp={() => this.handleMouseUp()}\r\n                      ></Node>\r\n                    );\r\n                  })}\r\n                </div>\r\n              );\r\n            })}\r\n          </div>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nconst getInitialGrid = (width, height) => {\r\n  const availableWidth = Math.floor(width * 0.8) - 50;\r\n  const availableHeight = Math.floor(height * 0.8) - 50;\r\n\r\n  const possibleRows = Math.floor(availableHeight / 25);\r\n  const possibleCols = Math.floor(availableWidth / 25);\r\n\r\n  START_NODE_ROW = Math.floor(Math.random() * possibleRows);\r\n  START_NODE_COL = Math.floor(Math.random() * possibleCols);\r\n\r\n  FINISH_NODE_ROW = Math.floor(Math.random() * possibleRows);\r\n  FINISH_NODE_COL = Math.floor(Math.random() * possibleCols);\r\n\r\n  const grid = [];\r\n\r\n  for (let row = 0; row < possibleRows; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < possibleCols; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n\r\n  return grid;\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    distance: Infinity,\r\n    totalDistance: Infinity,\r\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n    isWall: false,\r\n    isVisited: false,\r\n    previousNode: null,\r\n  };\r\n};\r\n\r\nconst getGridWithCellWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n","import { getUnvisitedNeighbors } from \"./common\";\r\n\r\nexport function bfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n\r\n  const queue = [];\r\n  queue.push(startNode);\r\n  startNode.isVisited = true;\r\n\r\n  while (queue) {\r\n    let current = queue.shift();\r\n    visitedNodesInOrder.push(current);\r\n\r\n    if (current === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(current, grid);\r\n\r\n    for (let unvisitedNeighbor of unvisitedNeighbors) {\r\n      queue.push(unvisitedNeighbor);\r\n      unvisitedNeighbor.isVisited = true;\r\n      unvisitedNeighbor.previousNode = current;\r\n    }\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n","import { getUnvisitedNeighbors } from \"./common\";\r\n\r\nexport function dfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n\r\n  const queue = [];\r\n  queue.push(startNode);\r\n\r\n  while (queue) {\r\n    let current = queue.pop();\r\n    visitedNodesInOrder.push(current);\r\n    current.isVisited = true;\r\n\r\n    if (current === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(current, grid);\r\n\r\n    for (let unvisitedNeighbor of unvisitedNeighbors) {\r\n      queue.push(unvisitedNeighbor);\r\n      unvisitedNeighbor.previousNode = current;\r\n    }\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n","import React from \"react\";\r\nimport \"./App.css\";\r\nimport Pathfinder from \"./pathfinder/PathFinder\";\r\n\r\nfunction App() {\r\n  return <Pathfinder></Pathfinder>;\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === \"localhost\" ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === \"[::1]\" ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener(\"load\", () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            \"This web app is being served cache-first by a service \" +\r\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then((registration) => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === \"installed\") {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                \"New content is available and will be used when all \" +\r\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log(\"Content is cached for offline use.\");\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch((error) => {\r\n      console.error(\"Error during service worker registration:\", error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { \"Service-Worker\": \"script\" },\r\n  })\r\n    .then((response) => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get(\"content-type\");\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then((registration) => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        \"No internet connection found. App is running in offline mode.\"\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if (\"serviceWorker\" in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then((registration) => {\r\n        registration.unregister();\r\n      })\r\n      .catch((error) => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport \"./index.css\";\r\nimport App from \"./App\";\r\nimport * as serviceWorker from \"./serviceWorker\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}